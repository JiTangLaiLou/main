保存数据用变量 运行程序用运算符 换算
运算符优先级
	1. a+b两个算子是双目运算符自左向右
	2. -a是单目优先级高与乘除 结合关系自右向左 
	3. 赋值最低结合关系同1 2  赋值也是运算符
	4. 其他自左向右
	5. 嵌入式赋值 阅读方式不同结果不同
复杂的方法叫套路 获得套路的方法是阅读和看别人怎么做的

	1. ++单目只能有一个算子还得是变量
	2. 前缀后缀a++以前结果附作用+1结果a+1
	结果和附作用不一定相同
	a=b结果b  附作用把b的值给了a
	3. inc递增 dec自减
if用法错误
	1. 建议尊重warning
	2. 凭空来上一个大括号c不觉得有问题
	3. If()里面=不能做比较
	赋值0对于if来说条件不成立不输出
	4. 大括号内要缩进
多路分支
	1. Switch( 控制表达式|只能整数不能浮点| ){}case 常量 :
	2. break直接带它离开 没有break往下做
	3. Default剩下的
	4. 常量可以是常数也可以是常数计算的表达式 case也得是表达式 const int a
	C99独占 (是const int独占)
	莫名其妙的数字 Magic number 所以要用常量定义
	5. 不是一个case对一个break不符合单一出口原则
	单一出口 把值铺给用户看了就是一个出口，出口只有一个   整个程序和怎么使用变量没有关系想做什么都可以，不然就写死了
嵌套
	1. else原则上被运行成与附近的if配套
	大括号可以影响先后顺序
	2. 缩进对配套没影响
级联
	1. 可用于分段函数
	2. 为了省空间被设计
	本质上也是嵌套
小套路
	1. 计算之前保存原始的值，后面可能有用|备份|
	2. 累加初始值要为0
	3. 考虑问题
	 循环多少次
	有没有输出0
	循环结束后的值
	4. 次数太多模拟较少的循环次数              
算平均数
	1. 需要的变量 计数器的变量
	需要的算法
画流程图 变成程序
	2. 1.0相乘直接变浮点
	3. scanf循环每次都读一遍变量不断改变
猜数游戏
	1. 重点是循环条件 思考方式需要加工
	2. #include <stdlib.h>
	#include <time.h>
	srand(time(0));
	int number rand();
	随机整数 
	3. x%n得到[0,n-1]以内的整数
	4. while()里面写的是循环成立的条件
整数求逆
	1. 对整数%10得到个位
	2. /10去掉个位
	3. 2的结果%10得到十位 
循环控制
	1. if（里面不用=）里面不用赋值用==
	2. 遇到break离开循环
	3. cintinue离开这一轮
嵌套的循环
	1. 循环里面还有循环
	2. 两个循环控制变量不同
	3. 需要一个就套一个
离开多重循环
	1. break和continue只能做它所在的循环
	2. 接力break
	3. goto+自定标号（goto out；—— out：）
	只在跳多重时候用，可能破坏程序结构性
求和
	1.      起点和终点数字都明确用for循环
最大公约数
	1. 变量表格法辗转相除法
	x
数据类型
	1. c是有类型的语言
	2. c++/java更强调类型更严格
	3. 其他不重视甚至不用定义
	4. 强类型有助于尽早发现错误
	5. 反对强类型有助于实现业务逻辑
	6. 基础类型
整数浮点逻辑指针自定义类型
	7. 表达形式
整型自然二进制/二进制补码
	浮点是编码形式两个无法在编码器里面做加法等计算
	8. sizeof（）
	=给出某个类型（int）或变量（a）占几个字节，1字节8bit
	char 1   short 2
	int 4      double 8 
	long 8   long long 16
	它是静态运算符不会做运算只能确定类型大小
整数类型
	1. -m32用32位编译
	2. int和long大小与编译器&CPU有关
	3. reg.寄存器=字长=bit
一次处理多少bit=int
	int就是用来表达寄存器的
整数的内部表达
	1. 所有的类型表明我们如何去看待它,而不是表明它在内部如何表达
	2. 二进制负数
		a.  补位 因为计算机1个字节只能8bit 表达00000000-
		11111111[0-255]
		b. 补码(当它是补码) 11111111=-1
纯二进制 =255
		c. 补码的意义是 补码和原码可以加出溢出的一个0   
		d. 补码概念和方法二把中间数当0不同




整数的范围
	1. 2的32次方-1--
	2. unsigned无补码后面加u/U   l/L表示long
	3. char(-128~127)
整数的格式化
	1. printf输入输出只有两种
内存小于int用int %d %d
	大于int用long long $ld %ld；ubsigned除外用%u
	2. 不管你在计算机内部是什么数，重点是以什么方式看它 
	不同的方式看 结果不同，和它内部本身无关，取决于是不是以正确的方式把它格式化成人能读懂的方式
	3. %u unsigned
	%ld long long
	%lu unsigned long long
	4. %o表示8进制
	%x 16进制
	
选择整数类型
	1. 硬件可能指定特定 整数类型
	2. unsigned与否只是输出的不同，内部计算是一样的
	
浮点类型
	1. 靠近0有部分无法表达
	2. 1e+10加号可省略
	3. double 15个
float   7位有效数字  多了可能不准确
	4. 计算机c语言能表达的数是离散的有限的数所以无法准确地表达
	5. %.15f\n 输出15位小数
默认6位四舍六入五留双
范围和精度
	1. printf输出inf表示超过范围的浮点数=±∞
输出nan表示不存在的浮点数
	2. 正数除以0为正无穷大，负数除以0为负无穷大，0除以0不存在（浮点数限定）无穷大无法用整数表达
无穷大和不存在是给浮点数定义的特定值
	3. 浮点运算没有精度 
	4. 带小数点的字面量是double而非float，float需要用f或F来表明身份:
float a之后 a=1.345f 不加f自动double，因为64位
	5. 两个浮点数直接用==判断是否相等可能失败
	6. 浮点运算误差可能累加
	7. fabs（）是求绝对值
